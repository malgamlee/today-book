{"ast":null,"code":"var util = require('./util');\n\nvar slice = util.slice;\nvar pluck = util.pluck;\nvar each = util.each;\nvar bind = util.bind;\nvar create = util.create;\nvar isList = util.isList;\nvar isFunction = util.isFunction;\nvar isObject = util.isObject;\nmodule.exports = {\n  createStore: createStore\n};\nvar storeAPI = {\n  version: '2.0.12',\n  enabled: false,\n  // get returns the value of the given key. If that value\n  // is undefined, it returns optionalDefaultValue instead.\n  get: function (key, optionalDefaultValue) {\n    var data = this.storage.read(this._namespacePrefix + key);\n    return this._deserialize(data, optionalDefaultValue);\n  },\n  // set will store the given value at key and returns value.\n  // Calling set with value === undefined is equivalent to calling remove.\n  set: function (key, value) {\n    if (value === undefined) {\n      return this.remove(key);\n    }\n\n    this.storage.write(this._namespacePrefix + key, this._serialize(value));\n    return value;\n  },\n  // remove deletes the key and value stored at the given key.\n  remove: function (key) {\n    this.storage.remove(this._namespacePrefix + key);\n  },\n  // each will call the given callback once for each key-value pair\n  // in this store.\n  each: function (callback) {\n    var self = this;\n    this.storage.each(function (val, namespacedKey) {\n      callback.call(self, self._deserialize(val), (namespacedKey || '').replace(self._namespaceRegexp, ''));\n    });\n  },\n  // clearAll will remove all the stored key-value pairs in this store.\n  clearAll: function () {\n    this.storage.clearAll();\n  },\n  // additional functionality that can't live in plugins\n  // ---------------------------------------------------\n  // hasNamespace returns true if this store instance has the given namespace.\n  hasNamespace: function (namespace) {\n    return this._namespacePrefix == '__storejs_' + namespace + '_';\n  },\n  // createStore creates a store.js instance with the first\n  // functioning storage in the list of storage candidates,\n  // and applies the the given mixins to the instance.\n  createStore: function () {\n    return createStore.apply(this, arguments);\n  },\n  addPlugin: function (plugin) {\n    this._addPlugin(plugin);\n  },\n  namespace: function (namespace) {\n    return createStore(this.storage, this.plugins, namespace);\n  }\n};\n\nfunction _warn() {\n  var _console = typeof console == 'undefined' ? null : console;\n\n  if (!_console) {\n    return;\n  }\n\n  var fn = _console.warn ? _console.warn : _console.log;\n  fn.apply(_console, arguments);\n}\n\nfunction createStore(storages, plugins, namespace) {\n  if (!namespace) {\n    namespace = '';\n  }\n\n  if (storages && !isList(storages)) {\n    storages = [storages];\n  }\n\n  if (plugins && !isList(plugins)) {\n    plugins = [plugins];\n  }\n\n  var namespacePrefix = namespace ? '__storejs_' + namespace + '_' : '';\n  var namespaceRegexp = namespace ? new RegExp('^' + namespacePrefix) : null;\n  var legalNamespaces = /^[a-zA-Z0-9_\\-]*$/; // alpha-numeric + underscore and dash\n\n  if (!legalNamespaces.test(namespace)) {\n    throw new Error('store.js namespaces can only have alphanumerics + underscores and dashes');\n  }\n\n  var _privateStoreProps = {\n    _namespacePrefix: namespacePrefix,\n    _namespaceRegexp: namespaceRegexp,\n    _testStorage: function (storage) {\n      try {\n        var testStr = '__storejs__test__';\n        storage.write(testStr, testStr);\n        var ok = storage.read(testStr) === testStr;\n        storage.remove(testStr);\n        return ok;\n      } catch (e) {\n        return false;\n      }\n    },\n    _assignPluginFnProp: function (pluginFnProp, propName) {\n      var oldFn = this[propName];\n\n      this[propName] = function pluginFn() {\n        var args = slice(arguments, 0);\n        var self = this; // super_fn calls the old function which was overwritten by\n        // this mixin.\n\n        function super_fn() {\n          if (!oldFn) {\n            return;\n          }\n\n          each(arguments, function (arg, i) {\n            args[i] = arg;\n          });\n          return oldFn.apply(self, args);\n        } // Give mixing function access to super_fn by prefixing all mixin function\n        // arguments with super_fn.\n\n\n        var newFnArgs = [super_fn].concat(args);\n        return pluginFnProp.apply(self, newFnArgs);\n      };\n    },\n    _serialize: function (obj) {\n      return JSON.stringify(obj);\n    },\n    _deserialize: function (strVal, defaultVal) {\n      if (!strVal) {\n        return defaultVal;\n      } // It is possible that a raw string value has been previously stored\n      // in a storage without using store.js, meaning it will be a raw\n      // string value instead of a JSON serialized string. By defaulting\n      // to the raw string value in case of a JSON parse error, we allow\n      // for past stored values to be forwards-compatible with store.js\n\n\n      var val = '';\n\n      try {\n        val = JSON.parse(strVal);\n      } catch (e) {\n        val = strVal;\n      }\n\n      return val !== undefined ? val : defaultVal;\n    },\n    _addStorage: function (storage) {\n      if (this.enabled) {\n        return;\n      }\n\n      if (this._testStorage(storage)) {\n        this.storage = storage;\n        this.enabled = true;\n      }\n    },\n    _addPlugin: function (plugin) {\n      var self = this; // If the plugin is an array, then add all plugins in the array.\n      // This allows for a plugin to depend on other plugins.\n\n      if (isList(plugin)) {\n        each(plugin, function (plugin) {\n          self._addPlugin(plugin);\n        });\n        return;\n      } // Keep track of all plugins we've seen so far, so that we\n      // don't add any of them twice.\n\n\n      var seenPlugin = pluck(this.plugins, function (seenPlugin) {\n        return plugin === seenPlugin;\n      });\n\n      if (seenPlugin) {\n        return;\n      }\n\n      this.plugins.push(plugin); // Check that the plugin is properly formed\n\n      if (!isFunction(plugin)) {\n        throw new Error('Plugins must be function values that return objects');\n      }\n\n      var pluginProperties = plugin.call(this);\n\n      if (!isObject(pluginProperties)) {\n        throw new Error('Plugins must return an object of function properties');\n      } // Add the plugin function properties to this store instance.\n\n\n      each(pluginProperties, function (pluginFnProp, propName) {\n        if (!isFunction(pluginFnProp)) {\n          throw new Error('Bad plugin property: ' + propName + ' from plugin ' + plugin.name + '. Plugins should only return functions.');\n        }\n\n        self._assignPluginFnProp(pluginFnProp, propName);\n      });\n    },\n    // Put deprecated properties in the private API, so as to not expose it to accidential\n    // discovery through inspection of the store object.\n    // Deprecated: addStorage\n    addStorage: function (storage) {\n      _warn('store.addStorage(storage) is deprecated. Use createStore([storages])');\n\n      this._addStorage(storage);\n    }\n  };\n  var store = create(_privateStoreProps, storeAPI, {\n    plugins: []\n  });\n  store.raw = {};\n  each(store, function (prop, propName) {\n    if (isFunction(prop)) {\n      store.raw[propName] = bind(store, prop);\n    }\n  });\n  each(storages, function (storage) {\n    store._addStorage(storage);\n  });\n  each(plugins, function (plugin) {\n    store._addPlugin(plugin);\n  });\n  return store;\n}","map":{"version":3,"names":["util","require","slice","pluck","each","bind","create","isList","isFunction","isObject","module","exports","createStore","storeAPI","version","enabled","get","key","optionalDefaultValue","data","storage","read","_namespacePrefix","_deserialize","set","value","undefined","remove","write","_serialize","callback","self","val","namespacedKey","call","replace","_namespaceRegexp","clearAll","hasNamespace","namespace","apply","arguments","addPlugin","plugin","_addPlugin","plugins","_warn","_console","console","fn","warn","log","storages","namespacePrefix","namespaceRegexp","RegExp","legalNamespaces","test","Error","_privateStoreProps","_testStorage","testStr","ok","e","_assignPluginFnProp","pluginFnProp","propName","oldFn","pluginFn","args","super_fn","arg","i","newFnArgs","concat","obj","JSON","stringify","strVal","defaultVal","parse","_addStorage","seenPlugin","push","pluginProperties","name","addStorage","store","raw","prop"],"sources":["/Users/jijeong/study/bookStore-app/node_modules/store/src/store-engine.js"],"sourcesContent":["var util = require('./util')\nvar slice = util.slice\nvar pluck = util.pluck\nvar each = util.each\nvar bind = util.bind\nvar create = util.create\nvar isList = util.isList\nvar isFunction = util.isFunction\nvar isObject = util.isObject\n\nmodule.exports = {\n\tcreateStore: createStore\n}\n\nvar storeAPI = {\n\tversion: '2.0.12',\n\tenabled: false,\n\t\n\t// get returns the value of the given key. If that value\n\t// is undefined, it returns optionalDefaultValue instead.\n\tget: function(key, optionalDefaultValue) {\n\t\tvar data = this.storage.read(this._namespacePrefix + key)\n\t\treturn this._deserialize(data, optionalDefaultValue)\n\t},\n\n\t// set will store the given value at key and returns value.\n\t// Calling set with value === undefined is equivalent to calling remove.\n\tset: function(key, value) {\n\t\tif (value === undefined) {\n\t\t\treturn this.remove(key)\n\t\t}\n\t\tthis.storage.write(this._namespacePrefix + key, this._serialize(value))\n\t\treturn value\n\t},\n\n\t// remove deletes the key and value stored at the given key.\n\tremove: function(key) {\n\t\tthis.storage.remove(this._namespacePrefix + key)\n\t},\n\n\t// each will call the given callback once for each key-value pair\n\t// in this store.\n\teach: function(callback) {\n\t\tvar self = this\n\t\tthis.storage.each(function(val, namespacedKey) {\n\t\t\tcallback.call(self, self._deserialize(val), (namespacedKey || '').replace(self._namespaceRegexp, ''))\n\t\t})\n\t},\n\n\t// clearAll will remove all the stored key-value pairs in this store.\n\tclearAll: function() {\n\t\tthis.storage.clearAll()\n\t},\n\n\t// additional functionality that can't live in plugins\n\t// ---------------------------------------------------\n\n\t// hasNamespace returns true if this store instance has the given namespace.\n\thasNamespace: function(namespace) {\n\t\treturn (this._namespacePrefix == '__storejs_'+namespace+'_')\n\t},\n\n\t// createStore creates a store.js instance with the first\n\t// functioning storage in the list of storage candidates,\n\t// and applies the the given mixins to the instance.\n\tcreateStore: function() {\n\t\treturn createStore.apply(this, arguments)\n\t},\n\t\n\taddPlugin: function(plugin) {\n\t\tthis._addPlugin(plugin)\n\t},\n\t\n\tnamespace: function(namespace) {\n\t\treturn createStore(this.storage, this.plugins, namespace)\n\t}\n}\n\nfunction _warn() {\n\tvar _console = (typeof console == 'undefined' ? null : console)\n\tif (!_console) { return }\n\tvar fn = (_console.warn ? _console.warn : _console.log)\n\tfn.apply(_console, arguments)\n}\n\nfunction createStore(storages, plugins, namespace) {\n\tif (!namespace) {\n\t\tnamespace = ''\n\t}\n\tif (storages && !isList(storages)) {\n\t\tstorages = [storages]\n\t}\n\tif (plugins && !isList(plugins)) {\n\t\tplugins = [plugins]\n\t}\n\n\tvar namespacePrefix = (namespace ? '__storejs_'+namespace+'_' : '')\n\tvar namespaceRegexp = (namespace ? new RegExp('^'+namespacePrefix) : null)\n\tvar legalNamespaces = /^[a-zA-Z0-9_\\-]*$/ // alpha-numeric + underscore and dash\n\tif (!legalNamespaces.test(namespace)) {\n\t\tthrow new Error('store.js namespaces can only have alphanumerics + underscores and dashes')\n\t}\n\t\n\tvar _privateStoreProps = {\n\t\t_namespacePrefix: namespacePrefix,\n\t\t_namespaceRegexp: namespaceRegexp,\n\n\t\t_testStorage: function(storage) {\n\t\t\ttry {\n\t\t\t\tvar testStr = '__storejs__test__'\n\t\t\t\tstorage.write(testStr, testStr)\n\t\t\t\tvar ok = (storage.read(testStr) === testStr)\n\t\t\t\tstorage.remove(testStr)\n\t\t\t\treturn ok\n\t\t\t} catch(e) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t},\n\n\t\t_assignPluginFnProp: function(pluginFnProp, propName) {\n\t\t\tvar oldFn = this[propName]\n\t\t\tthis[propName] = function pluginFn() {\n\t\t\t\tvar args = slice(arguments, 0)\n\t\t\t\tvar self = this\n\n\t\t\t\t// super_fn calls the old function which was overwritten by\n\t\t\t\t// this mixin.\n\t\t\t\tfunction super_fn() {\n\t\t\t\t\tif (!oldFn) { return }\n\t\t\t\t\teach(arguments, function(arg, i) {\n\t\t\t\t\t\targs[i] = arg\n\t\t\t\t\t})\n\t\t\t\t\treturn oldFn.apply(self, args)\n\t\t\t\t}\n\n\t\t\t\t// Give mixing function access to super_fn by prefixing all mixin function\n\t\t\t\t// arguments with super_fn.\n\t\t\t\tvar newFnArgs = [super_fn].concat(args)\n\n\t\t\t\treturn pluginFnProp.apply(self, newFnArgs)\n\t\t\t}\n\t\t},\n\n\t\t_serialize: function(obj) {\n\t\t\treturn JSON.stringify(obj)\n\t\t},\n\n\t\t_deserialize: function(strVal, defaultVal) {\n\t\t\tif (!strVal) { return defaultVal }\n\t\t\t// It is possible that a raw string value has been previously stored\n\t\t\t// in a storage without using store.js, meaning it will be a raw\n\t\t\t// string value instead of a JSON serialized string. By defaulting\n\t\t\t// to the raw string value in case of a JSON parse error, we allow\n\t\t\t// for past stored values to be forwards-compatible with store.js\n\t\t\tvar val = ''\n\t\t\ttry { val = JSON.parse(strVal) }\n\t\t\tcatch(e) { val = strVal }\n\n\t\t\treturn (val !== undefined ? val : defaultVal)\n\t\t},\n\t\t\n\t\t_addStorage: function(storage) {\n\t\t\tif (this.enabled) { return }\n\t\t\tif (this._testStorage(storage)) {\n\t\t\t\tthis.storage = storage\n\t\t\t\tthis.enabled = true\n\t\t\t}\n\t\t},\n\n\t\t_addPlugin: function(plugin) {\n\t\t\tvar self = this\n\n\t\t\t// If the plugin is an array, then add all plugins in the array.\n\t\t\t// This allows for a plugin to depend on other plugins.\n\t\t\tif (isList(plugin)) {\n\t\t\t\teach(plugin, function(plugin) {\n\t\t\t\t\tself._addPlugin(plugin)\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Keep track of all plugins we've seen so far, so that we\n\t\t\t// don't add any of them twice.\n\t\t\tvar seenPlugin = pluck(this.plugins, function(seenPlugin) {\n\t\t\t\treturn (plugin === seenPlugin)\n\t\t\t})\n\t\t\tif (seenPlugin) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tthis.plugins.push(plugin)\n\n\t\t\t// Check that the plugin is properly formed\n\t\t\tif (!isFunction(plugin)) {\n\t\t\t\tthrow new Error('Plugins must be function values that return objects')\n\t\t\t}\n\n\t\t\tvar pluginProperties = plugin.call(this)\n\t\t\tif (!isObject(pluginProperties)) {\n\t\t\t\tthrow new Error('Plugins must return an object of function properties')\n\t\t\t}\n\n\t\t\t// Add the plugin function properties to this store instance.\n\t\t\teach(pluginProperties, function(pluginFnProp, propName) {\n\t\t\t\tif (!isFunction(pluginFnProp)) {\n\t\t\t\t\tthrow new Error('Bad plugin property: '+propName+' from plugin '+plugin.name+'. Plugins should only return functions.')\n\t\t\t\t}\n\t\t\t\tself._assignPluginFnProp(pluginFnProp, propName)\n\t\t\t})\n\t\t},\n\t\t\n\t\t// Put deprecated properties in the private API, so as to not expose it to accidential\n\t\t// discovery through inspection of the store object.\n\t\t\n\t\t// Deprecated: addStorage\n\t\taddStorage: function(storage) {\n\t\t\t_warn('store.addStorage(storage) is deprecated. Use createStore([storages])')\n\t\t\tthis._addStorage(storage)\n\t\t}\n\t}\n\n\tvar store = create(_privateStoreProps, storeAPI, {\n\t\tplugins: []\n\t})\n\tstore.raw = {}\n\teach(store, function(prop, propName) {\n\t\tif (isFunction(prop)) {\n\t\t\tstore.raw[propName] = bind(store, prop)\t\t\t\n\t\t}\n\t})\n\teach(storages, function(storage) {\n\t\tstore._addStorage(storage)\n\t})\n\teach(plugins, function(plugin) {\n\t\tstore._addPlugin(plugin)\n\t})\n\treturn store\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}